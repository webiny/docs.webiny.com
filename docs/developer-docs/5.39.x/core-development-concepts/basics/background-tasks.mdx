---
id: 8f6fo7e4
title: Background Tasks
description: You will learn about Background Tasks, how to create new definitions, how to trigger them and how to handle the task run.
---

import {Alert} from "@/components/Alert";
import {CanIUseThis} from "@/components/CanIUseThis";
import {WhatYouWillLearn} from "@/components/WhatYouWillLearn";
import backgroundTaskStepFunction from "./backgroundTasks/bg-task-step-function.png";

<Alert type="danger" title="Use with caution!">
  This feature is experimental and is subject to change in future releases.
</Alert>

<CanIUseThis since={"5.39.0"} />

<WhatYouWillLearn>

- how Background Tasks work
- how to define your own Background Task
- what to be careful about

</WhatYouWillLearn>

## About

In the 5.39.0 version of Webiny we have introduced a Background Task feature.
This feature enables our users to run operations which take a long time to finish - more than available 15 minutes timeout of the AWS Lambda.

The Background Task run limit is 1 year, which is the maximum execution time for the AWS Step Function.

This functionality uses the AWS Event Bridge, AWS Step Function and AWS Lambda to run the Background Tasks.

<Alert type="warning" title="AWS Lambda Timeout">
  AWS Lambda has a maximum timeout of 15 minutes. If you think your code takes longer than 15 minutes to finish, you must split it into smaller chunks. Read more about it <a href="#the-is-close-to-timeout-method">here</a>.
</Alert>

## How It Works

1. A user can trigger the task either via [GraphQL API mutation](#trigger-a-background-task) or directly via the [code](#).
2. As soon as the task is triggered, Webiny sends an EventBridge Event with task information: task ID and definition identifier.
3. The EventBridge triggers the Step Function.
4. The Step Function runs the Lambda function in a loop until the task is done.

### Step Function Definition

We defined our Step Function as simple as possible, with a lot of error handling, as we did not want to have complex logic in the Step Function itself.

The Pulumi definition for the Step Function is available [here](https://github.com/webiny/webiny-js/blob/34aab967ee5088974323762edb0507261727d0a4/packages/pulumi-aws/src/apps/api/backgroundTask/definition.ts#L13).

<Image src={backgroundTaskStepFunction} alt="Background Task Step Function Definition" />

### Step Function States

#### TransformEvent

This state is responsible for transforming the EventBridge Event into the Background Task Lambda handler input.

It is required as we want to have simple Background Task Lambda handler input, without any additional information.
This is what the Step Function receives from the EventBridge:

```json
{
  "version": "0",
  "id": "37eb2fb9-6c54-48cf-afba-e0ea2988305a",
  "detail-type": "WebinyBackgroundTask",
  "source": "webiny-api-tasks",
  "account": "xxxxxxxxxxx",
  "time": "2024-01-1T15:30:00Z",
  "region": "eu-central-1",
  "resources": [],
  "detail": {
    "webinyTaskId": "65b26a4af5a5d9fc684af039",
    "webinyTaskDefinitionId": "myTaskDefinition",
    "tenant": "root",
    "locale": "en-US"
  }
}
```

and this is what we need to run a Background Task Lambda handler:

```json
{
  "webinyTaskId": "65b26a4af5a5d9fc684af039",
  "webinyTaskDefinitionId": "myTaskDefinition",
  "locale": "en-US",
  "tenant": "root"
}
```

So, basically, this state is responsible for removing all the unnecessary information from the EventBridge Event.

#### Run

This state is responsible for running the Background Task Lambda. It runs the Lambda, with the input from the previous state - either `TransformEvent` or previous `Run` state, and waits for the response.

When it receives a response from the Lambda handler, it is sent to the `CheckStatus` state.

#### CheckStatus

This state is responsible for checking the status of the Background Task Lambda Handler response.

Possible response statuses are:

- done
- error
- aborted
- continue

##### Done Status

This status signalizes that the Background Task Lambda handler has finished its job and that the Step Function will finish as well.

##### Error Status

This status signalizes that the Background Task Lambda handler has finished its job with an error and that the Step Function will finish as well, in an error state.

##### Aborted Status

This status signalizes that the Background Task Lambda handler has finished its job with an abort and that the Step Function will finish as well, in an abort state.

##### Continue Status

This status signalizes that the Background Task Lambda handler has not finished its job and that the Step Function should continue running the Lambda handler.

When user ends current execution of the Background Task Lambda handler, they can also include a waiting time for the next handler run.
This can be used when the task needs to wait for some external service to finish its job, before the next handler run.
The task must contain the logic for checking if the external service has finished its job, and continue the task execution accordingly.

#### UnknownError

This state is called when the Step Function Background Task Lambda handler has an unknown error (`Run` state).
This should not happen as the Webiny code always returns a proper response, and everything is wrapped in a `try/catch` block - with the error response in the catch block.

But, if it happens, for some really strange reason, the Step Function will finish in an error state.

#### UnknownStatus

This state is called when the Step Function Background Task Lambda handler returns an unknown status, and the `CheckStatus` state determines that the status is unknown.
This should not happen as the Webiny code gives all the tools to the user to return a proper response, and everything is wrapped in a `try/catch` block - with the error response in the catch block.

But, if it happens, for some really strange reason, the Step Function will finish in an error state.

#### Error

This state is called when the Step Function Background Task Lambda handler returns an error status, and the `CheckStatus` state determines that the status is error.

The Step function will finish in an error state.

#### Done

This state is called when the Step Function Background Task Lambda handler returns a done status, and the `CheckStatus` state determines that the status is done.

The step function will finish in a success state.

#### Aborted

This state is called when the Step Function Background Task Lambda handler returns an abort status, and the `CheckStatus` state determines that the status is aborted.

The step function will finish in a success state, as the abort state was triggered by the user.

### Background Task Lambda Handler

The Background Task Lambda is deployed with the same code as our GraphQL API Lambda code, with an exception having more memory assigned.

This way all of your custom code is deployed within the Background Task Lambda as well.

The response of the Background Task Lambda handler is plain JSON, with the following structure:

```typescript
status: "done" | "error" | "continue" | "aborted";
webinyTaskId: string;
webinyTaskDefinitionId: string;
tenant: string;
locale: string;
```

But users do not need to worry about the response structure, as it is handled by the tools which are provided in the task run.

### How To Define A Background Task

First, you need to know that there are two types of Background Tasks:
- public ones - can be called via GraphQL API or the code
- private ones - can be called only through the code

Definition of the task is the same for both types of tasks, with a difference of the method name used to define the task:

```typescript
import { createTaskDefinition, createPrivateTaskDefinition } from "@webiny/tasks";

// public task
const myPublicTaskDefinition = createTaskDefinition({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run(params) {
        // your code here
    },
});
// private task
const myPrivateTaskDefinition = createPrivateTaskDefinition({
    id: "myPrivateTask",
    title: "A Task Accessible Only Via The Code",
    async run(params) {
        // your code here
    }
});

// of course, you must load the task definition in the plugins array in createHandler method.

export const handler = createHandler({
    plugins: [
        // ...rest of plugins
        myPublicTaskDefinition,
        myPrivateTaskDefinition
    ]
});
```

#### Advanced Definition

```typescript
const myPublicTaskDefinition = createTaskDefinition({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run(params) {
        // your code here
    },
    maxIterations: 1000,// default is 500
});
```

In the examples we will provide, we will use the public task definition, as the code is the same for both types of tasks.

### Handling The Task Run

When you define the task, you need to provide the `run` method, as it is the method getting executed when the task is being executed.
The `run` method receives an object parameter with the following variables, defined in the interface [`ITaskRunParams`](https://github.com/webiny/webiny-js/blob/34aab967ee5088974323762edb0507261727d0a4/packages/tasks/src/types.ts#L241) :

- context
- input
- response
- isCloseToTimeout
- isAborted
- store

#### The `context` Object

Via the `context` object, you can access whole Webiny system.
The base interface of the `context` object is [Context](https://github.com/webiny/webiny-js/blob/34aab967ee5088974323762edb0507261727d0a4/packages/tasks/src/types.ts#L237), but you can pass your own, which must extend the base interface.

You can pass your own interface/type of the `context` variable when defining the task:
```typescript
import {createTaskDefinition} from "@webiny/tasks";
import {MyCustomContext} from "./types";

const myTask = createTaskDefinition<MyCustomContext>({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run({context}) {
        // context is of type MyCustomContext
        await context.yourCustomMethod();
    }
});
```

#### The `input` Object

The `input` object is the input which was sent to the task when it was triggered.

By default, it is of plain object type `Record<string, any>`, but you can pass your own type/interface when defining the task:
```typescript
import {createTaskDefinition} from "@webiny/tasks";
import {MyCustomContext} from "./types";

interface MyCustomInput {
    myCustomProperty: string;
}

const myTask = createTaskDefinition<MyCustomContext, MyCustomInput>({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run({input}) {
        // input is of type MyCustomInput
        const {myCustomProperty} = input;
    }
});
```

#### The `response` Object

The `response` object handles the output from the task run.
Available methods are:
- done
- continue
- error
- aborted

##### The `done` Method

This method signalizes that the task has finished its job and that the Step Function will finish as well.
It also signalizes that task status should be set to `success`. Optional message will be stored as well.
```typescript
import {createTaskDefinition} from "@webiny/tasks";

const myTask = createTaskDefinition({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run({response}) {
        return response.done("Optional message about the task getting done.");
    }
});
```

##### The `continue` Method

This method signalizes that the task has not finished its job and that the Step Function should continue running the Lambda handler.

Note that the `continue` method MUST receive some data, which is of same type as the input variable, as the first parameter.

Why? Because the data you send into `continue` is the data you will receive on the next iteration of the task run as the `input` variable.

The `continue` method accepts a second, optional, parameter via which you can set waiting time for the next task run.
You can either send a `seconds` property, which takes a number, or a `date` property, which takes a `Date` object.

```typescript
import {createTaskDefinition} from "@webiny/tasks";

const myTask = createTaskDefinition({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run({input, response}) {
        return response.continue({
            ...input,
            aChangedInputProperty: 1,
        },
            // optional options
        {
            seconds: 30, // wait 30 seconds before the next task run
            date: new Date("2024-02-25T00:00:00Z") // wait until the specified date before the next task run
        });
    }
});
```

<Alert type="danger">
  If you are setting waiting time for the `continue` method, note that the maximum waiting time is 355 days, which is almost the maximum life time for the AWS Step Function.
</Alert>

##### The `error` Method

This method signalizes that the task has finished its job with an error and that the Step Function will finish as well, in an error state.
It also signalizes that task status should be set to `error`.
```typescript
import {createTaskDefinition} from "@webiny/tasks";

const myTask = createTaskDefinition({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run({response}) {
        return response.error({
            message: "Error message",
            code: "ERROR_CODE",
            data: {
                // optional data
            }
        });
    }
});
````

##### The `abort` Method

This method signalizes that the task was aborted by the user. Note that this is not an error, but a user triggered abort.

When you write your code, you must check if the task was aborted via the `isAborted()` method, and if it was, you must return the `abort` response.
This is meant to be used while the task has some code which loops continuously, like reading a lot of records from the database, with paginating through the records.

```typescript
import {createTaskDefinition} from "@webiny/tasks";

const myTask = createTaskDefinition({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run({response, isAborted, input}) {
        let dbReadParams = {
            ...input,
        };
        let result: DbResponse | null = null;
        while ((result = await listFromDb(dbReadParams))) {
          if (isAborted()) {
              return response.abort();
          }
          // continue with the loop
        }
        return response.done();
    }
});
````

#### The `isCloseToTimeout` Method

The `isCloseToTimeout` method is a method which returns a boolean value, which tells you if the Lambda instance is close to the timeout.
This is useful when you have a lot of code to run, or you have some idea that the code will take some time to execute, and you want to check if you have enough time to finish the code execution.

```typescript
import {createTaskDefinition} from "@webiny/tasks";

interface MyInput {
    after?: null | undefined;
}

const myTask = createTaskDefinition<Context, MyInput>({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run({response, isCloseToTimeout, input}) {
        let dbReadParams = {
            ...input,
        };
        let result: DbResponse;
        while ((result = await listFromDb(dbReadParams))) {
          // do your magic...
          
          // assign the cursor to the after property of the dbReadParams
          dbReadParams.after = result.cursor;
          if (isCloseToTimeout()) {
              // on next iteration, we want to continue with new dbReadParams 
              return response.continue(dbReadParams);
          }
          // continue with the loop
        }
        return response.done();
    }
});
```

The `isCloseToTimeout` method accepts an optional parameter, which is a number of seconds under which will this method return `true`. The default is `180` seconds.

<Alert type="warning">

  As a developer, you are responsible for checking if the task is close to the timeout, and for handling the task run accordingly.

  Webiny provides you with the background task mechanism, but you must handle the task run, and timeouts, yourself.

</Alert>

#### The `isAborted` Method

The `isAborted` method is a method which returns a boolean value, which tells you if the task was aborted by the user.

```typescript
import {createTaskDefinition} from "@webiny/tasks";

const myTask = createTaskDefinition({
    id: "myPublicTask",
    title: "A Task Accessible Via API",
    async run({response, isAborted, input}) {
        let dbReadParams = {
            ...input,
        };
        let result: DbResponse | null = null;
        while ((result = await listFromDb(dbReadParams))) {
          if (isAborted()) {
              return response.abort();
          }
          // continue with the loop
        }
        return response.done();
    }
});
````

#### The `store` Object

The `store` object is of `ITaskManagerStore` interface type, which is defined [here](https://github.com/webiny/webiny-js/blob/34aab967ee5088974323762edb0507261727d0a4/packages/tasks/src/runner/abstractions/TaskManagerStore.ts#L42).

It is used for storing and retrieving data from the task run, including task logs.

Available methods on the object are:
- `getTask`
- `getStatus`
- `updateTask`
- `updateInput`
- `getInput`
- `addInfoLog`
- `addErrorLog`

### Logging

Because the Background Task Lambda handler can be executed multiple times, depending on the developer response, the logging has been implemented on per iteration base.

It means that each of the execution iteration gets its own record, which contain individual logs from that execution iteration.

<Alert type="warning" title="Logging">

  Do not use the `addInfoLog` and `addErrorLog` methods for a lot of logging, or logging large amounts of data.
  
  The logs are stored in the database as you send them, and if you send a lot of logs, or large logs, you will hammer the database.
  
  Use the logs only for important information, like starting/finishing a part of a task.

</Alert>

## GraphQL API

The Background Tasks do not have a section in the Admin UI yet, so they are accessible only via the GraphQL API.

### List All Background Task Definitions

```graphql
query ListTaskDefinitions {
  backgroundTasks {
    listDefinitions {
      data {
        id
        title
        description
      }
      error {
        message
        code
        data
        stack
      }
    }
  }
}
```

### List All Background Task Runs
```graphql
query ListTasks {
  backgroundTasks {
    listTasks {
      data {
        id
        startedOn
        finishedOn
        name
        definitionId
        executionName
        eventResponse
        taskStatus
        input
        # ... more fields available
      }
      error {
        message
        code
        data
        stack
      }
    }
  }
}
```

### Trigger a Background Task

```graphql
mutation TriggerATask {
  backgroundTasks {
    triggerTask(definition: testingRun, input: {
      someVariableForTestingRunTaskToReceive: "someValue",
      yetAnotherVariableForTestingRunTaskToReceive: "anotherValue"
    }) {
      data {
        id
        # ... more fields available
      }
      error {
        message
        code
        data
        stack
      }
    }
  }
}
```

### Abort a Background Task

```graphql
mutation AbortATask {
  backgroundTasks {
    # message is optional
    abortTask(id: "yourTaskId", message: "My Reason for aborting the task") {
      data {
        id
        # ... more fields available
      }
      error {
        message
        code
        data
        stack
      }
    }
  }
}
```

### List Background Task Logs

```graphql
query ListBackgroundTaskLogs {
  backgroundTasks(where: {
    # you can list logs from a certain task if you like
    task: "yourTaskId"
  }) {
    listLogs {
      data {
        id
        createdOn
        task {
          id
          name
        }
        executionName
        iteration
        items {
          message
          createdOn
          type
          data
          error
        }
      }
    }
  }
}
```

## Code API

For examples, we will assume you are somewhere in the code where you have access to the Webiny `context` object.

### List All Background Task Definitions

```typescript
const results = await context.tasks.listDefinitions();
```

### List All Background Task Runs

```typescript
const results = await context.tasks.listTasks({
    // all properties are optional
    where: {},
    sort: [],
    limit: 100,
    after: null
});
```

### Trigger a Background Task

```typescript
const result = await context.tasks.trigger({
    definition: "myTaskDefinition",
    // optional input for the task run
    input: {
        variableToPassAsInput: "someValue"
    },
    // optional name for the task run
    name: "My Custom Task Name"
});
```

### Abort a Background Task

```typescript
const result = await context.tasks.trigger({
    id: "yourTaskId",
    // optional message
    message: "My Reason for aborting the task"
});
```

### List Background Task Logs

```typescript
const results = await context.tasks.listLogs({
    // all properties are optional
    where: {},
    sort: [],
    limit: 100,
    after: null
});
```

## Built-in Background Tasks

Webiny ships with a few of built-in Background Tasks. Some of them are used only internally (like clearing Cloudfront file cache), and some of them can be used publicly (Elasticsearch reindexing).

### Test Task

The test task is a task which is used for testing the Background Task mechanism.
Its definition is available [here](https://github.com/webiny/webiny-js/blob/de38392959f2692d1feb08945a3588cd80e4924c/packages/tasks/src/tasks/testingRunTask.ts#L3).


### Elasticsearch Reindexing Task

<Alert type="info" title="Elasticsearch And OpenSearch Only!">
  This task will only get shipped with Elasticsearch and OpenSearch Webiny system.
</Alert>


The Elasticsearch/OpenSearch Reindexing is the first task we implemented via the Background Task mechanism.
Basically, it is a task which scans through the DynamoDB Elasticsearch table and pushes the data into the specific Elasticsearch/OpenSearch index.
Internally it is a bit more than that, but this is the basic idea. You can check the [definition](https://github.com/webiny/webiny-js/blob/34aab967ee5088974323762edb0507261727d0a4/packages/api-elasticsearch-tasks/src/tasks/reindexing/reindexingTaskDefinition.ts#L12) and the [runner](https://github.com/webiny/webiny-js/blob/34aab967ee5088974323762edb0507261727d0a4/packages/api-elasticsearch-tasks/src/tasks/reindexing/ReindexingTaskRunner.ts#L40) code for more information.

The task can be triggered either via code or via the GraphQL API.

#### Triggering the Task Via Code

Let's say that you have a Page Builder lifecycle event hook which triggers the task when the page is published, but only on index which contains the word `page` in its name.
```typescript
const myHook = () => {
    return new ContextPlugin(async(context) => {
        context.pageBuilder.onPageAfterPublish(async() => {
            await context.tasks.trigger({
                definition: "elasticsearchReindexing",
                input: {
                    matching: "page"
                }
            });
        })
    });
};
```

#### Triggering The Task Via GraphQL API

The task can be triggered via the GraphQL API, with the following mutation:
```graphql
mutation TriggerTask {
  backgroundTasks {
    triggerTask(definition: elasticsearchReindexing, input: {
      matching: "page"
    }) {
      data {
        id
      }
      error {
        message
        code
        data
        stack
      }
    }
  }
}
```

The task disables indexing on all matching indexes, and enables it when the task is finished.
This is done to reduce the strain on the Elasticsearch/OpenSearch cluster as the reindexing operation is a heavy one.

## What To Be Careful About

### Lambda Timeout

AWS Lambda can run up to 15 minutes. Webiny provides a mechanism for checking on how much time is there left before the Lambda times out, but it is up to the developer to use it. You can read about it [here](#the-is-close-to-timeout-method).

### Step Function Timeout

AWS Step Function can live up to 1 year. This is the maximum time for the Step Function, set by AWS, and it cannot be increased.

### Step Function Execution Limit

AWS Step Function has a hard limit of 25,000 state changes - executions. It cannot be increased.

### Step Function State Change Limit

AWS Step Function does not provide a built-in mechanism to limit the number of state changes on each task run.

This means that a task can go into the loop and execute up to 25,000 times, which is something that we want to avoid, or at least, control it.

What Webiny does to help with this is count the number of the Lambda handler executions, and if the number is greater than defined, it will end the task with an error.

Default limit: `500`.

To change the limit, see [`maxIterations`](#how-to-define-a-background-task) parameter when defining the Background Task.


## Permissions

To run, abort, list and view the Background Tasks, the user must have a `Full Access`. In future releases we will fine grain the permissions.

<Alert title="Resumable Background Tasks" type="warning">
  Currently, Background Tasks are not using the Task Token, so they are not resumable. We will be
  working on the solution for this in the future.
</Alert>
