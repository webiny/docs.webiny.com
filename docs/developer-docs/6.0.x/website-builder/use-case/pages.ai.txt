AI Context: Page Use Cases (website-builder/use-case/pages.mdx)

Source of Information:
1. Read /Users/brunozoric/work/webiny/webiny-beta-test/testing-v6.0.0/extensions/websiteBuilder/pages/useCase files
2. Analyzed page use case implementations (create, update, delete, publish, unpublish, get, list)
3. Examined the use case pattern and structure
4. Studied page-specific business logic and validations
5. Reviewed repository integration patterns

Key Documentation Decisions:
- Document all page-related use cases
- Follow the established use case pattern from CMS documentation
- Show abstraction and implementation patterns
- Include page-specific business logic
- Demonstrate publishing workflow integration
- Cover CRUD and publishing operations
- Include error handling with Result pattern

Use Cases Documented:
1. Create Page - Create new pages with validation
2. Update Page - Modify existing pages
3. Delete Page - Remove pages with dependency checks
4. Get Page - Retrieve single page
5. List Pages - Query multiple pages with filters
6. Publish Page - Make page public with validation
7. Unpublish Page - Remove page from public view
8. Clone Page - Duplicate existing pages

Pattern Used:
- Interface definition
- Error types (validation, authorization, repository, publishing errors)
- createAbstraction call
- Namespace export with all types
- createImplementation pattern
- Repository dependency injection
- Result pattern for error handling
- Page-specific validation (URL, template, SEO)
- Publishing workflow logic

Page-Specific Logic:
- URL path validation and conflict resolution
- Template validation
- SEO metadata validation
- Publishing prerequisites check
- Version management
- Draft/published state management

Verification Done:
- Read actual use case implementation files from symlinked remote folder
- Verified method signatures and parameters
- Confirmed return types
- Validated business logic patterns
- Ensured consistency with actual implementations

Related Documents:
- headless-cms/use-case/entry.mdx - Similar use case patterns
- headless-cms/use-case/model.mdx - Use case structure reference
- website-builder/event-handler/pages.mdx - Event integration
- basic/di.mdx - Abstraction creation patterns
- basic/result.mdx - Result pattern usage

Key Code Locations:
- Source code: remote/websiteBuilder/pages/useCase/* (symlinked via ./remote)
- Abstraction pattern: See CMS use cases for reference
- Real implementations: /Users/brunozoric/work/webiny/webiny-beta-test/testing-v6.0.0/extensions/websiteBuilder/pages/useCase

Use Case Structure to Follow:
```typescript
// 1. Define interface
export interface ICreatePageUseCase {
    execute(input: Input): Promise<Result<Page, Error>>;
}

// 2. Define errors
export interface ICreatePageUseCaseErrors {
    validation: ValidationError;
    authorization: AuthorizationError;
}
type UseCaseError = ICreatePageUseCaseErrors[keyof ICreatePageUseCaseErrors];

// 3. Create abstraction
export const CreatePageUseCase = createAbstraction<ICreatePageUseCase>("WebsiteBuilder/CreatePage");

// 4. Export namespace with everything
export namespace CreatePageUseCase {
    export type Interface = ICreatePageUseCase;
    export type Input = CreatePageInput;
    export type Error = UseCaseError;
    export type Return = Promise<Result<Page, UseCaseError>>;
}

// 5. Create implementation
export const createPageUseCase = CreatePageUseCase.createImplementation({
    async execute(input) {
        // implementation
    }
});
```

Common Patterns:
1. Follow the 5-step structure above
2. Use namespace for all type exports
3. Inject dependencies via createImplementation
4. Validate in use cases, persist in repositories
5. Trigger events where appropriate
6. Always use Result pattern

Tone Guidelines:
- Technical and precise
- Show complete patterns
- Include page-specific validations
- Reference actual implementation files


