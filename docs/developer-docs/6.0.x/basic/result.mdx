---
id: bpki4nn3
title: Result
description: About Result
---










import {Alert} from "@/components/Alert";

<Alert type="success" title="WHAT YOU'LL LEARN">

- What is the `Result`?
- How to use it?
- How to use the return types?

</Alert>

## Overview

In Webiny v6 we have moved away returning a plain value directly and throwing exceptions as a result of a method or function.

We are now utilizing the `Result` pattern, and we have a `Result` class that helps us with that.

The `Result` pattern is a way to represent the outcome of an operation that can either succeed or fail.
Instead of throwing exceptions, functions return a `Result` object that encapsulates either a successful value or an error.

## Usage

Let's say we have a function that performs some async call to an operation which we import from our dependency, and it can either return a result or throw an error.

```typescript
import {Result} from "webiny/api";
import {someOperation} from "some-module";

const myMethod = async() => {
  try {
    const operationResult = await someOperation();
    return Result.ok(operationResult);
  } catch(ex) {
    return Result.fail(ex);
  }
}
const result = await myMethod();
if(result.isOk()) {
  console.log("Operation succeeded with value:", result.value);
} else {
  console.error("Operation failed with error:", result.error);
}
```

This way we can be sure that the method does not throw an exception, and we do not have to worry about it down the call stack, which uses the `myMethod` function.

## Return Types

When using the `Result` pattern the return types are inferred from the values passed to the `Result.ok()` and `Result.fail()` methods.

For example, if we have a function that returns a `Result` object with a successful value of type `string` and an error of type `Error`, the return type would be `Result<string, Error>`.

```typescript
import {Result} from "webiny/api";
const myMethod = async(): Promise<Result<string, Error>> => {
  try {
    const operationResult = await someOperation();
    return Result.ok(operationResult);
  } catch(ex) {
    return Result.fail(ex);
  }
}
```

For more complex return types, we can define custom types for the success value and error value.

```typescript
import type { Result } from "webiny/api";
import type { NotAuthorizedError, ValueNotFoundError } from "webiny/api/error";

export interface SuccessData {
    id: string;
    name: string;
}
export interface Success {
    data: SuccessData;
    timestamp: number;
}
interface PossibleErrors {
    notFound: ValueNotFoundError;
    notAuthorized: NotAuthorizedError;
}

type MyMethodErrors = PossibleErrors[keyof PossibleErrors];

type ReturnOfTheMethod = Promise<Result<Success, MyMethodErrors>>;

interface MyMethodParams {
    id: string;
}

export interface MyMethod {
    (params: MyMethodParams): ReturnOfTheMethod;
}
```

And then we can implement the method like this:

```typescript
const myMethod: MyMethod = async (params) => {
    try {
        const operationResult = await someOperation(params.id);
        if (!operationResult) {
            return Result.fail(new ValueNotFoundError(`Value with ID ${params.id} not found.`));
        }
        const successData: SuccessData = {
            id: operationResult.id,
            name: operationResult.name,
        };
        return Result.ok({
            data: successData,
            timestamp: Date.now(),
        });
    } catch (ex) {
        return Result.fail(new NotAuthorizedError(`Not authorized to access value with ID ${params.id}.`));
    }
};
```

## Result Unwrap

When using `Webiny` methods and functions that return a `Result` object, you might want to get the actual value or error types from the `Result` object.

If the type is not available for you to import, you can use the `Result.UnwrapResult` and `Result.UnwrapError` utility to get those types.

For example, using our `GetEntryByIdUseCase` from Headless CMS:

```typescript
import type { Result } from "webiny/api";
import type { GetEntryByIdUseCase } from "webiny/api/cms/entry";

export type IGetEntryByIdValue = Result.UnwrapResult<GetEntryByIdUseCase.Result>;
export type IGetEntryByIdError = Result.UnwrapError<GetEntryByIdUseCase.Result>;
```

This can be useful when you want to use return types from Webiny through your own code, but the types are not directly available for import.


## Conclusion
The `Result` pattern is a powerful way to handle success and failure in your code without relying on exceptions.
By using the `Result` class, you can create functions that return a `Result` object, making it easier to manage errors and success values in a consistent manner.
Additionally, the ability to infer return types from the `Result` object allows for better type safety and clarity in your code.
