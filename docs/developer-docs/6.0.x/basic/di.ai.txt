AI Context: Dependency Injection (di.mdx)

Source of Information:
1. Read the @webiny/di package README from the linked repository (https://github.com/webiny/di)
2. Analyzed the di-readme.md file that was provided in the 6.0.x folder
3. Examined existing examples in 6.0.x files to understand how abstractions and implementations are used in practice
4. Reviewed the CreateEntryUseCase abstraction example provided by the user, which showed:
   - How to use createAbstraction
   - Interface definition patterns
   - Namespace exports pattern
   - Error type definitions
   - Proper TypeScript typing

Understanding Dependency Injection (DI):
DI is a pattern where you don't create dependencies directly in your code. Instead, you define what you need (interface/abstraction) and something else provides it (implementation). This makes code:
- Testable: Easy to swap real services with test doubles
- Flexible: Can change implementations without changing code
- Maintainable: Clear separation of "what" vs "how"

Simple Analogy:
Think of ordering food at a restaurant. You say "I want a burger" (interface/abstraction). The kitchen decides how to make it (implementation). You don't care if they use oven A or oven B, you just want a burger.

In the DI System:
1. Abstraction = The "what" (interface) - "I need something that can save users"
2. Implementation = The "how" (concrete code) - "Here's code that saves users to database"
3. Container = The system that connects requests to services

External Package Used:
This system uses @webiny/di - a type-safe dependency injection library designed for TypeScript.

Key Documentation Decisions:
- Focus on createAbstraction and createImplementation API
- Keep examples simple and generic (Book/Author/Category domain)
- Show the namespace pattern used throughout codebase
- Export everything users need from the namespace (types, interfaces, errors)
- Demonstrate the Result pattern integration
- Use the prefix pattern for abstraction names (e.g., "Library/CreateBook")
- Did not include automatic discovery or advanced topics per user instruction
- Removed comments from example code except for pedagogical correct/wrong comparisons

Example Pattern Used:
- Interface definition
- Error types definition
- createAbstraction call
- Namespace export with all necessary types
- const export of the abstraction
- createImplementation usage from the namespace

The 5-Step Pattern:

Step 1: Define the Interface (What you need)
```typescript
export interface ISaveBookUseCase {
    execute(book: Book): Promise<Result<Book, Error>>;
}
```

Step 2: Define Error Types
```typescript
export interface ISaveBookUseCaseErrors {
    validation: ValidationError;
    database: DatabaseError;
}
type UseCaseError = ISaveBookUseCaseErrors[keyof ISaveBookUseCaseErrors];
```

Step 3: Create the Abstraction (Register it)
```typescript
export const SaveBookUseCase = createAbstraction<ISaveBookUseCase>("Library/SaveBook");
```
The string "Library/SaveBook" is a unique name (like an ID) for this abstraction.

Step 4: Export Everything in a Namespace
```typescript
export namespace SaveBookUseCase {
    export type Interface = ISaveBookUseCase;
    export type Error = UseCaseError;
    // Export all types someone needs to use or implement this
}
```
Why? So users have everything in one place: SaveBookUseCase.Interface, SaveBookUseCase.Error

Step 5: Create Implementation (The actual code)
```typescript
export const saveBookUseCase = SaveBookUseCase.createImplementation({
    database: DatabaseService // Dependencies it needs
}, async ({ database }, book) => {
    // Your actual logic here
    await database.save(book);
    return Result.ok(book);
});
```

Related Documents:
- See headless-cms/use-case/*.mdx for real-world abstraction examples
- See headless-cms/event-handler/*.mdx for implementation examples
- See basic/result.mdx for the Result pattern (used with DI)

Key Code Locations:
Note: For AI agents to examine source code implementations, provide access to your Webiny project repository.
- @webiny/di package: https://github.com/webiny/di
- Example abstractions: extensions/[module]/[feature]/abstraction/
- Example implementations: extensions/[module]/[feature]/useCase/

Common Patterns to Follow:
1. Always export both namespace and const
2. Use Result pattern for error handling
3. Prefix abstraction names (e.g., "Cms/CreateEntry")
4. Export all types users need from namespace
5. Keep examples generic (avoid CMS-specific examples in this doc)

Tone Guidelines:
- Be concise and technical
- Focus on what's unique to this DI implementation
- Show complete patterns with all 5 steps
- Mention @webiny/di as the external package being used

