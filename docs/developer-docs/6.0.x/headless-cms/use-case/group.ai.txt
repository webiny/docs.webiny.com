AI Context: Group Use Cases (headless-cms/use-case/group.mdx)

Source of Information:
1. Analyzed use case patterns from existing documentation
2. Read group use case implementations from symlinked remote folder
3. Examined create, update, delete, get, list use cases
4. Studied the abstraction and implementation patterns
5. Understood repository integration

Key Documentation Decisions:
- Document all group-related use cases
- Show abstraction creation pattern
- Include implementation examples
- Demonstrate repository integration
- Show error handling with Result pattern
- Include validation patterns
- Cover CRUD operations comprehensively

Use Cases Documented:
1. Create Group - Create new content groups
2. Update Group - Modify existing groups
3. Delete Group - Remove groups
4. Get Group - Retrieve single group
5. List Groups - Query multiple groups

Pattern Used:
- Interface definition
- Error types (validation, authorization, repository errors)
- createAbstraction call
- Namespace export with all types
- createImplementation pattern
- Repository dependency injection
- Result pattern for error handling
- Validation logic
- Authorization checks

Implementation Details:
- Dependency injection of repositories
- Error type unions
- Type-safe implementations
- Result.ok() for success
- Result.fail() for errors
- Repository method calls

Related Documents:
- headless-cms/use-case/model.mdx - Model use cases (similar pattern)
- headless-cms/use-case/entry.mdx - Entry use cases (similar pattern)
- headless-cms/event-handler/group.mdx - Event integration
- headless-cms/builder/group.mdx - Group builder
- basic/di.mdx - Abstraction patterns

Key Code Locations:
Note: To examine source code implementations, configure your development environment to allow agent access to the installation directory and package source files.
- Source: installation directory

Use Case Pattern (following established structure):
```typescript
// 1. Interface
export interface ICreateGroupUseCase {
    execute(input: CreateGroupInput): Promise<Result<CmsGroup, UseCaseError>>;
}

// 2. Errors
export interface ICreateGroupUseCaseErrors {
    notAuthorized: GroupNotAuthorizedError;
    validation: GroupValidationError;
    repository: RepositoryError;
}
type UseCaseError = ICreateGroupUseCaseErrors[keyof ICreateGroupUseCaseErrors];

// 3. Abstraction
export const CreateGroupUseCase = createAbstraction<ICreateGroupUseCase>("Cms/CreateGroup");

// 4. Namespace
export namespace CreateGroupUseCase {
    export type Interface = ICreateGroupUseCase;
    export type Input = CreateGroupInput;
    export type Error = UseCaseError;
    export type Return = Promise<Result<CmsGroup, UseCaseError>>;
}

// 5. Implementation
export const createGroupUseCase = CreateGroupUseCase.createImplementation({
    repository: CreateGroupRepository
}, async ({ repository }, input) => {
    // Validation
    // Business logic
    // Persistence
    return Result.ok(group);
});
```

Use Cases to Document:
1. Create Group - New group with validation
2. Update Group - Modify existing group
3. Delete Group - Remove (check for models)
4. Get Group - Retrieve single group
5. List Groups - Query multiple groups

Common Validations:
- Slug uniqueness
- Name requirements
- Authorization checks
- Model dependency (before delete)

Tone Guidelines:
- Follow established use case pattern
- Show complete abstraction structure
- Include namespace exports
- Reference CMS entry/model for consistency

