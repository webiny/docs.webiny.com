AI Context: Background Tasks - Reference (tasks/reference.mdx)

Source of Information:
1. Analyzed code examples provided by the user showing background task implementation
2. Examined the task runner pattern with context and controller
3. Studied the ITasks interface and its methods
4. Reviewed task definition, triggering, and execution patterns
5. Understood the event-driven architecture with onBefore/onAfter hooks

Key Documentation Decisions:
- Comprehensive reference documentation covering all aspects
- Explained the three main components: Runner, Context, Controller
- Documented task definition structure
- Showed how to trigger tasks
- Explained task execution flow
- Included event handlers (onBeforeRun, onAfterRun)
- Added task management operations (get, list, update, delete)
- Used practical examples throughout
- Maintained junior-friendly explanations while being technically complete

Main Sections:
1. Task Definition - Structure and properties (id, name, input, etc.)
2. Triggering Tasks - Using context.tasks.trigger()
3. Task Execution - Runner pattern with iterate() and run()
4. Task Context - Available properties and methods
5. Task Controller - Control flow (abort, success, error, status)
6. Event Handlers - Lifecycle hooks
7. Task Management - CRUD operations

Pattern Observed:
- Tasks defined with name and input
- Triggered via context.tasks.trigger()
- Executed by runners using iterate() pattern
- Context provides access to task data and operations
- Controller manages task status and output
- Result pattern used throughout

Note: Document was refined after user feedback to ensure reader understand all concepts (async, iteration, controllers, triggering, etc.)

Related Documents:
- tasks/about.mdx - Conceptual introduction
- tasks/management.mdx - Task CRUD operations
- All event-handler/*.mdx files use similar patterns

Task Runner Pattern to Follow:
```typescript
export const MyTaskRunner = {
    async iterate(context) {
        const tasks = await context.tasks.getTasks({ name: "myTask" });
        return tasks;
    },
    async run(task, context, controller) {
        logger.info("Running task", { taskId: task.id });

        // Process task
        const result = await doWork(task.input);

        if (result.isFail()) {
            return controller.error(result.error);
        }

        return controller.success(result.value);
    }
};
```

Task Triggering Pattern:
```typescript
const result = await context.tasks.trigger({
    name: "myTask",
    input: { data: "value" }
});
```

Task Definition Structure:
- id: string (auto-generated)
- name: string (task type identifier)
- input: any (task-specific data)
- status: "pending" | "success" | "failed" | "aborted"
- output: any (result data)
- error: any (error information)

Common Patterns:
1. Use iterate() to find tasks to process
2. Use run() to execute individual tasks
3. Controller methods: success(), error(), abort(), status()
4. Always use logger for debugging
5. Handle errors gracefully

Reader Notes:
- Tasks are async operations outside HTTP cycle
- Runner.iterate() finds tasks to process
- Runner.run() processes one task
- Controller manages task status
- Context provides access to task operations

Tone Guidelines:
- Explain concepts clearly
- Provide complete examples
- Show the full lifecycle (define → trigger → execute)

