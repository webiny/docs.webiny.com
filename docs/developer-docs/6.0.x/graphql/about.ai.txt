AI Context: GraphQL - About (graphql/about.mdx)

Source of Information:
1. Read graphql/reference.mdx and graphql/example.mdx to understand implementation
2. Analyzed the GraphQL schema factory pattern used in Webiny
3. Examined type and resolver registration patterns
4. Understood the declarative schema building approach

Key Documentation Decisions:
- Created introductory document explaining GraphQL integration in Webiny
- Focused on the factory pattern approach (not traditional schema-first or code-first)
- Explained the declarative nature of schema building
- Described the two main components: types and resolvers
- Kept it conceptual rather than implementation-focused
- Made it accessible for developers new to Webiny's GraphQL approach
- Linked to example and reference docs for implementation details

Document Structure:
- Overview: How GraphQL works in Webiny
- What You'll Learn
- Factory Pattern explanation
- Types and Resolvers concepts
- Why this approach (modularity, extensibility, type safety)
- Links to practical examples

Key Concepts Explained:
- GraphQL schema factory pattern
- Type definitions (objects, inputs, enums)
- Resolvers for fields and queries/mutations
- Declarative schema building
- Modularity and extensibility benefits

Target Audience: Developers who need to extend or customize GraphQL APIs in Webiny, coming from traditional GraphQL backgrounds (Apollo, TypeGraphQL, etc.)

Related Documents:
- graphql/reference.mdx - Factory API methods
- graphql/example.mdx - Complete working examples
- All use-case/*.mdx files show resolver integration

Key Concepts to Explain:
1. Factory pattern (not schema-first or code-first)
2. Declarative schema building
3. Type and resolver separation
4. Modularity and extensibility

Webiny's Approach vs Traditional:
- Traditional: Schema-first (SDL) or code-first (decorators)
- Webiny: Factory pattern (programmatic, modular)
- Benefits: Type safety, modularity, extensibility

Factory Pattern Components:
1. Types - Object types, inputs, enums, interfaces
2. Resolvers - Query/mutation/field logic
3. Schema building - Declarative registration

Document Structure:
- Overview: How GraphQL works in Webiny
- What You'll Learn
- Factory pattern explanation
- Types and resolvers concepts
- Why this approach (benefits)
- Links to reference and examples

Key Benefits to Explain:
- Type safety with TypeScript
- Modular schema building
- Easy extension without schema conflicts
- Integration with DI container
- Separation of concerns

Tone Guidelines:
- Conceptual introduction
- Compare to familiar approaches
- Explain the "why" of factory pattern
- Link to practical examples

