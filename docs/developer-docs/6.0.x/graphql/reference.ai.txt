AI Context: GraphQL - Reference (graphql/reference.mdx)

Source of Information:
1. Analyzed small code example for GraphQL schema factory provided by user
2. Examined factory methods for creating types, inputs, and resolvers
3. Studied the API surface of the GraphQL factory
4. Understood the type registration and schema building process

Key Documentation Decisions:
- Simple, concise reference documentation
- Focus on the factory API methods
- Document each factory method (createObjectType, createInputObjectType, createResolver)
- Show method signatures and options
- Keep examples minimal but illustrative
- Explain when to use each method
- Cross-reference with example.mdx for complete implementations

Methods Documented:
1. createObjectType() - Define GraphQL object types
2. createInputObjectType() - Define input types for mutations
3. createResolver() - Implement query/mutation logic
4. Type system integration

Overview Written:
- Explains that factory provides declarative API
- Describes type safety benefits
- Notes the modular nature
- Keeps it simple and to-the-point

Pattern Observed:
- Factory pattern for schema building
- Type definitions separate from resolvers
- Declarative API design
- Integration with TypeScript for type safety

Tone: Consistent with other reference docs, using "Webiny provides/offers", explaining functionality clearly and concisely, avoiding unnecessary "we" statements.

Related Documents:
- graphql/about.mdx - Conceptual overview
- graphql/example.mdx - Complete examples

Factory Methods to Document:
1. createObjectType() - Define GraphQL object types
2. createInputObjectType() - Define input types
3. createResolver() - Implement query/mutation logic

Method Signatures:
```typescript
// Object Type
factory.createObjectType({
    name: "TypeName",
    fields: {
        fieldName: { type: "String!" },
        relation: { type: "RelatedType" }
    }
});

// Input Type
factory.createInputObjectType({
    name: "InputName",
    fields: {
        fieldName: { type: "String!" }
    }
});

// Resolver
factory.createResolver({
    type: "Query" | "Mutation",
    field: "fieldName",
    resolve: async (source, args, context) => {
        // resolver logic
    }
});
```

Type System Notes:
- Use "!" for required fields
- Reference other types by name (string)
- Support for scalars, objects, lists
- TypeScript type safety

Common Patterns:
1. Define types first
2. Create inputs for mutations
3. Implement resolvers separately
4. Use context for dependencies

Tone Guidelines:
- Reference documentation style
- Simple, concise examples
- Focus on API surface
- Link to example.mdx for complete implementations

